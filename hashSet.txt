/*
💡 Title: How HashSet Achieves O(1) Lookup in Java 🚀
📘 Author: Gaith Nahdi
📅 Date: October 2025

---

### 🔍 Introduction

When solving algorithmic problems like “Longest Consecutive Sequence” (LeetCode 128),
we often see solutions using `HashSet` instead of `List` or `ArrayList`.

But *why* does `HashSet` make things faster? How does it magically find if a number exists in O(1)?
Let’s break down the secret behind it.

---

### ⚙️ What is a HashSet?

`HashSet` in Java is a **data structure** that stores unique elements and gives you
super-fast lookups, insertions, and deletions — all in **O(1)** average time.

Internally, `HashSet` is built on top of a `HashMap`.  
When you add an element to a `HashSet`, it’s actually stored as a **key** in the underlying `HashMap`,
and the value is a dummy object.

---

### ⚡ How Does HashSet Work?

Here’s the step-by-step of what happens when you call `numSet.add(num)`:

1️⃣ Java calls the method `num.hashCode()` — this returns an integer that represents
   where the number should be stored in memory (a *bucket index*).

2️⃣ Using that hash code, Java calculates the **bucket position** in an internal array.
   - Example: if hash code = 42, it might go to bucket index `42 % capacity`.

3️⃣ If that bucket is empty, Java stores the value there.
   If it’s occupied (hash collision), it uses **linked lists or balanced trees**
   to handle multiple items in the same bucket.

4️⃣ When you check `numSet.contains(x)`, Java again calculates the hash of `x`,
   jumps to the right bucket immediately, and checks if `x` is inside.

✅ Result: **No need to scan the entire list** → O(1) average time!

---

### 🧩 Example — Longest Consecutive Sequence

Let’s see this in action. The code below solves LeetCode problem 128 in O(n) time using a `HashSet`.

*/

import java.util.HashSet;
import java.util.Set;

public class Solution {

    public int longestConsecutive(int[] nums) {
        if (nums.length == 0) return 0;

        // Step 1: Store all numbers in a HashSet for O(1) lookups
        Set<Integer> numSet = new HashSet<>();
        for (int num : nums) {
            numSet.add(num);
        }

        int longest = 0;

        // Step 2: Check each number as a potential start of a sequence
        for (int num : numSet) {
            if (!numSet.contains(num - 1)) { // start of a sequence
                int current = num;
                int length = 1;

                // Step 3: Count consecutive numbers
                while (numSet.contains(current + 1)) {
                    current += 1;
                    length += 1;
                }

                longest = Math.max(longest, length);
            }
        }

        return longest;
    }

    // Test
    public static void main(String[] args) {
        Solution s = new Solution();
        int[] nums = {10, 1, 3, 7, 13, 11, 2, 4};
        System.out.println("Longest consecutive sequence length: " + s.longestConsecutive(nums));
    }
}

/*
---

### 🧠 Why Not Use a List?

If you used a `List`, each lookup like `list.contains(x)` would scan the entire list — O(n).
In the worst case, this becomes O(n²) for the full algorithm.
That’s why `HashSet` is the hero here.

---

### ⚖️ Summary

| Operation      | ArrayList | HashSet  |
|----------------|-----------|----------|
| Lookup         | O(n)      | O(1)     |
| Insert         | O(1)*     | O(1)     |
| Delete         | O(n)      | O(1)     |
| Duplicates     | Allowed   | Not allowed |

\*Average case

---

### 🏁 Final Words

Next time you see `HashSet` in a solution, remember:
it’s not magic — it’s **hashing** that gives you direct access to data in constant time.

🔥 `HashSet` = smart use of hash codes + efficient memory structure.

Written with ❤️ by Gaith — “Code smart, not hard.”
*/
