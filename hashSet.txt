/*
ğŸ’¡ Title: How HashSet Achieves O(1) Lookup in Java ğŸš€
ğŸ“˜ Author: Gaith Nahdi
ğŸ“… Date: October 2025

---

### ğŸ” Introduction

When solving algorithmic problems like â€œLongest Consecutive Sequenceâ€ (LeetCode 128),
we often see solutions using `HashSet` instead of `List` or `ArrayList`.

But *why* does `HashSet` make things faster? How does it magically find if a number exists in O(1)?
Letâ€™s break down the secret behind it.

---

### âš™ï¸ What is a HashSet?

`HashSet` in Java is a **data structure** that stores unique elements and gives you
super-fast lookups, insertions, and deletions â€” all in **O(1)** average time.

Internally, `HashSet` is built on top of a `HashMap`.  
When you add an element to a `HashSet`, itâ€™s actually stored as a **key** in the underlying `HashMap`,
and the value is a dummy object.

---

### âš¡ How Does HashSet Work?

Hereâ€™s the step-by-step of what happens when you call `numSet.add(num)`:

1ï¸âƒ£ Java calls the method `num.hashCode()` â€” this returns an integer that represents
   where the number should be stored in memory (a *bucket index*).

2ï¸âƒ£ Using that hash code, Java calculates the **bucket position** in an internal array.
   - Example: if hash code = 42, it might go to bucket index `42 % capacity`.

3ï¸âƒ£ If that bucket is empty, Java stores the value there.
   If itâ€™s occupied (hash collision), it uses **linked lists or balanced trees**
   to handle multiple items in the same bucket.

4ï¸âƒ£ When you check `numSet.contains(x)`, Java again calculates the hash of `x`,
   jumps to the right bucket immediately, and checks if `x` is inside.

âœ… Result: **No need to scan the entire list** â†’ O(1) average time!

---

### ğŸ§© Example â€” Longest Consecutive Sequence

Letâ€™s see this in action. The code below solves LeetCode problem 128 in O(n) time using a `HashSet`.

*/

import java.util.HashSet;
import java.util.Set;

public class Solution {

    public int longestConsecutive(int[] nums) {
        if (nums.length == 0) return 0;

        // Step 1: Store all numbers in a HashSet for O(1) lookups
        Set<Integer> numSet = new HashSet<>();
        for (int num : nums) {
            numSet.add(num);
        }

        int longest = 0;

        // Step 2: Check each number as a potential start of a sequence
        for (int num : numSet) {
            if (!numSet.contains(num - 1)) { // start of a sequence
                int current = num;
                int length = 1;

                // Step 3: Count consecutive numbers
                while (numSet.contains(current + 1)) {
                    current += 1;
                    length += 1;
                }

                longest = Math.max(longest, length);
            }
        }

        return longest;
    }

    // Test
    public static void main(String[] args) {
        Solution s = new Solution();
        int[] nums = {10, 1, 3, 7, 13, 11, 2, 4};
        System.out.println("Longest consecutive sequence length: " + s.longestConsecutive(nums));
    }
}

/*
---

### ğŸ§  Why Not Use a List?

If you used a `List`, each lookup like `list.contains(x)` would scan the entire list â€” O(n).
In the worst case, this becomes O(nÂ²) for the full algorithm.
Thatâ€™s why `HashSet` is the hero here.

---

### âš–ï¸ Summary

| Operation      | ArrayList | HashSet  |
|----------------|-----------|----------|
| Lookup         | O(n)      | O(1)     |
| Insert         | O(1)*     | O(1)     |
| Delete         | O(n)      | O(1)     |
| Duplicates     | Allowed   | Not allowed |

\*Average case

---

### ğŸ Final Words

Next time you see `HashSet` in a solution, remember:
itâ€™s not magic â€” itâ€™s **hashing** that gives you direct access to data in constant time.

ğŸ”¥ `HashSet` = smart use of hash codes + efficient memory structure.

Written with â¤ï¸ by Gaith â€” â€œCode smart, not hard.â€
*/
